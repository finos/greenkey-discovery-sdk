#!/usr/bin/env python3

import glob
import json

from os.path import join as join_path
from os.path import dirname
from testing.discovery_config import DISABLE_INTENTS_WHITELIST


def expand_wildcard_tests(directory, tests):
    """
    Expands any wildcard filenames in the list of tests

    >>> res = expand_wildcard_tests('examples/fruits', ['test*'])
    >>> sorted(res)
    ['tests.txt', 'tests_negative.txt']

    >>> expand_wildcard_tests('skip_this_directory', ['no_wildcards'])
    ['no_wildcards']
    """
    if any('*' in t for t in tests):
        wildcard_tests = [t for t in tests if '*' in t]
        expanded_filenames = [ \
            glob.glob(join_path(directory, add_extension_if_missing(t))) \
            for t in wildcard_tests \
        ]
        flattened_filenames = [i for s in expanded_filenames for i in s]
        cleaned_filenames = [
            p.replace(directory, '').strip("/") for p in flattened_filenames
        ]
        tests = [t for t in tests if not t in wildcard_tests] + cleaned_filenames
    return tests


def load_tests_into_list(tests):
    """
    Take either space or comma separated tests and split into a list of tests
    """
    target_tests = []
    for test in tests:
        target_tests += [
            subtest.strip()
            for subtest in (test.split(",") if isinstance(test, str) else test)
            if subtest.strip()
        ]
    return target_tests


def store_previous_test(tests, current_test):
    if current_test and set(current_test.keys()) != set(['test', 'transcript', 'external_entities']):
        tests.append(current_test)
    return tests


def parse_test_line(line, tests, current_test, test_folder):
    key, value = line.split(": ", maxsplit=1)
    if key == "test":
        tests = store_previous_test(tests, current_test)
        current_test = {key: value}
    elif key == "external_entities":
        ent_file = join_path(test_folder, 'external_entities', value)
        current_test[key] = json.load(open(ent_file, 'r'))['entities']
    elif key == "schema":
        # Since we can have more than one schema test,
        # store the test so that the current_test is still available
        # to add to the new tests
        current_test[key] = value
        tests = store_previous_test(tests, current_test)
        current_test = {k: v for k, v in current_test.items() if k != "schema"}
    elif key:
        current_test[key] = value
    return tests, current_test


def load_test_file(test_file):
    return [_.strip() for _ in open(test_file) if _.strip() and not _.startswith("#")]


def load_tests(test_file):
    """
    Loads and parses the test file
    """
    test_list = load_test_file(test_file)
    test_list, intent_whitelist, domain_whitelist = find_whitelists(test_list)
    test_directory = dirname(test_file)

    tests = []
    current_test = {}
    for line in test_list:
        try:
            tests, current_test = parse_test_line(line, tests, current_test, test_directory)
        except ValueError:
            continue

    tests = store_previous_test(tests, current_test)
    return tests, intent_whitelist, domain_whitelist


def find_whitelists(test_file):
    """
    If testfile starts with any whitelists, separate them from the test file.
    """

    intents = [intent for intent in test_file if intent.startswith("intent_whitelist")]
    domains = [domain for domain in test_file if domain.startswith("domain_whitelist")]

    intent_whitelist = format_whitelist(intents[0]) if intents else ["any"]
    domain_whitelist = format_whitelist(domains[0]) if domains else ["any"]

    test_file = [line for line in test_file if not line in intents + domains]

    if DISABLE_INTENTS_WHITELIST:
        intent_whitelist = ["any"]

    return test_file, intent_whitelist, domain_whitelist


def format_whitelist(line):
    """
    Ensure whitelist is a list if it contains commas.
    """
    _, whitelist = line.split(":", maxsplit=1)

    if "," in whitelist:
        whitelist = [_.strip() for _ in whitelist.split(",")]
    else:
        whitelist = [whitelist.strip()]
    return whitelist


def report_domain_whitelists(directory, tests):
    return (find_whitelists(
        load_test_file(join_path(directory, add_extension_if_missing(f))))[2]
            for f in (tests.split(",") if isinstance(tests, str) else tests))


def add_extension_if_missing(test_file):
    """
    Add .txt extension if not present
    >>> add_extension_if_missing('this')
    'this.txt'
    >>> add_extension_if_missing('that.txt')
    'that.txt'
    """
    if not test_file.endswith(".txt"):
        test_file += ".txt"
    return test_file
